@[TOC](文章目录)

---

# ⭐前言
&emsp;&emsp;在日常生活中使用计算机时，大家会不会出现这样一种好奇，为什么我们打开很多应用或者在玩游戏的过程中，会听到主板上中央处理器（Central Processing Unit，CPU）的散热装置**轰轰轰**的工作声音，而打开一少部分的应用时，CPU的这个散热装置就几乎没有声音，不难想到的是，CPU散热装置声音越大，代表着我们的CPU正在进行着越高强度的工作。那么我们打开这么多的应用（**进程**），硬件是怎么知道的呢？这一切的功劳都归于我们的操作系统（Operating System，OS）。对于OS，我们可以简单的理解为是**我们使用的上层应用与底层硬件资源**交互的媒介，它为用户提供了使用硬件资源的**接口**（`Windows11`将这个接口进行了**图形化**，使得我们可以方便的使用硬件），它也可以通过**识别用户对接口**的使用，进行硬件资源的**调度**（分配）。


---

# 一、浅谈OS的各个管理模块对应的硬件资源
&emsp;&emsp;通过**前言**部分，我们从最宏观的角度知道了什么是OS，对于**科班**的小伙伴，相信大家在学习OS理论时，大部分的教学路径基本是**进程管理，内存管理，文件管理，输入输出（Input Output，IO）设备管理**。笔者认为，这样安排的理论教学是有原因的，从硬件的角度思考，它可以让学生**结合OS和硬件资源**，对计算机体系结构有一个很好的入门。
&emsp;&emsp;**进程管理**，它结合的硬件资源是我们的最核心部件**CPU**，当我们**切换**OS的上层应用时（比如用微信聊完天后，打开我们的游戏），OS就会触发进程管理，将微信这个进程切换下去，让我们的游戏进程占用CPU。

&emsp;&emsp;**内存管理**，它结合的硬件资源是我们常说的**内存条**，有编程的小伙伴知道，我们写的代码（**也叫程序**），是各种格式的文本文件，它经过**预处理 ⇒ 链接 ⇒ 编译 ⇒ 汇编**之后，会生成**可执行文件**，这些文件都是存储在**磁盘**中的，我们要**运行这个可执行文件**（比如点击桌面上的微信可执行程序快捷键），需要将它拿到内存条上来。那么将可执行程序拿到内存条上来时，内存管理就要考虑**如何组织这些程序存放到内存中**，比如分块、分页（块和页可以理解为分离程序的基本单位）或者连续。

&emsp;&emsp;**文件管理**，它结合的硬件资源是我们常说的**磁盘（固态硬盘，机械硬盘）**，很好理解，文件管理负责的是将我们需要存放在计算机里面的东西**进行组织与管理**，和内存管理很类似，文件管理对一个文件进行组织，宏观上的两种方式是分块或者连续。此外，大家在学习文件管理或者看文件属性的时候，大概率接触过**文件系统（File System）**，文件系统可以简单的理解为**文件管理的一种规范**，不同OS的**文件管理规范是不一样的**。

&emsp;&emsp;**IO设备管理**，它结合的硬件资源是我们常说的**IO设备**，这个好理解，常见的**输入**设备比如我们的键盘、鼠标和麦克风等，常见的**输出**设备比如我们的显卡、网卡和打印机等。IO设备管理主要针对的是IO设备**硬件资源**，它结合对应的**驱动程序**，完成计算机内部的信号与IO设备的信号交互，有效地组合和管理IO设备的分配，正是因为有了IO设备，我们的计算机有了强大计算能力的同时，还衍生出了一系列**其他的功能**（办公、影音和娱乐等）。
# 二、从OS的各个管理模块浅谈进程管理
&emsp;&emsp;本章内容主要从**进程的角度**，结合CPU硬件资源，来探讨进程是干什么的，OS又是从哪些方面来实现进程管理的。
## 2.1 什么是进程？
&emsp;&emsp;相信大家对进程一点都不陌生，当我们打开Windows OS的任务管理器，如下图所示，就能在**进程页面**看到很多用户进程和系统进程，并且我们还能发现，它是**动态占用CPU和内存等硬件资源的**，所以，这里得到**进程和程序（我们写的代码）的最大区别**，也是进程的最主要特征，它是**动态的**、可以发生**状态转换的**、有**生命周期的**。我们也可以简单的理解为进程是**程序 + 数据**的动态运行。
<center><img src="https://i-blog.csdnimg.cn/direct/36142ff0800c45c1a1e1a7782ab9c1de.png" width="85%"></center>

## 2.2 我知道进程是啥啦，那么OS怎么知道进程的呢？
&emsp;&emsp;作为聪明的人类，我们可以很容易的对进程的概念进行定义和理解，但是，OS把可执行文件**从磁盘装入到内存条中**后，又该如何将其转换为进程呢？其实，OS系统对于**装入在内存条中的可执行文件**，会为其创建一个叫做**进程控制块(Process Control Block，PCB)** 的数据结构，如下图所示，是xv6操作系统源码的PCB数据结构。OS为一个可执行文件创建了PCB，就能够感知进程的存在了，并且通过PCB控制着进程的**运行状态**。
<center><img src="https://i-blog.csdnimg.cn/direct/127857da110e4773b72f65e018a7a73c.png" width="85%"></center>


# 三、OS是如何进行进程管理？
&emsp;&emsp;OS知道了内存条中装载着的进程，那么在我们**使用OS上层应用**的时候，OS是如何对进程进行管理的呢？笔者认为，从**入门和宏观**的角度来看，OS对进程进行管理，可以分为**三大部分**，第一部分为**进程的状态转换**，第二部分为**进程调度**，第三部分为**进程间通信**，接下来我们对这三部分**结合案例**进行探讨。
## 3.1 进程状态转换
&emsp;&emsp;要知道进程状态是**如何转换的**，我们首先应该了解一下，什么是**进程的状态**，进程一共有**几种状态**。进程状态，简单的理解就是**描述进程在OS运行过程中，是以什么样的状态存在的**，OS通过PCB感知进程的存在，并且以此**控制进程的状态**。进程的状态有**5种**（一些资料在加入了线程的理解下，会认为进程有7种状态，对于**了解进程入门，我们只需要知道进程的5种状态就行了**），分别是**创建态、运行态、就绪态、阻塞态和结束态**。
### 3.1.1 创建态
&emsp;&emsp;**创建态**是每一个进程都**必须经历的状态**，只有经历了**创建态**，OS才能感知到进程的存在，以我们点击VS2019为例，此时VS2019可执行文件被**加载进入内存条**，OS为该可执行文件**创建一个空白的PCB**，并且向PCB种填入必要的**控制和管理进程**的信息，然后为该进程分配**运行所需的硬件资源（如内存条、文件索引节点等）**，至此，进程的**创建**就完成了。
&emsp;&emsp;在进程创建态最后一步，也是最容易忽视的一步是，进程创建完毕后，会从创建态转换为就绪态，插入就绪队列（一种存储着**就绪状态PCB的数据结构**）中，等待进程调度。

<center><img src="https://i-blog.csdnimg.cn/direct/87bdc55dda08460895bba1b5109f72a9.png" width="85%"></center>

### 3.1.2 运行态
&emsp;&emsp;运行态，顾名思义，就是运行中的进程，以我正在QQ音乐中听音乐为例，此时**QQ音乐进程就处于运行态**，**运行状态的进程**占用CPU硬件资源，CPU **执行对应的二进制指令**。试想一下，OS中存在着大量的进程，如果我们的QQ音乐进程一直占用所有的CPU资源，那些维持OS正常运行的系统进程**就得不到CPU资源**，这样OS不就崩溃了？其实，OS对于运行态的进程，是有一直在切换的（比如我们的QQ音乐进程就不可能一直在运行），只是**CPU工作频率达到了GHz（执行一条指令只需$10^{-9}s$）**，人类对OS的进程切换是感觉不出来的。
<center><img src="https://i-blog.csdnimg.cn/direct/206a9e7aa46241e5b68b3b1cfe94788c.png" width="85%"></center>

### 3.1.3 就绪态
&emsp;&emsp;**就绪态**也很好理解，就是对应的**PCB存储在就绪队列**的进程，这些进程由于**进程调度(下面会讲解，这里简单的理解为CPU对运行的进程进行切换)** 的原因，失去了CPU的使用权，而进程继续运行下去所需的**其他硬件资源**都充足，这时，进程就会进入就绪态。就绪态的案例不好演示，还是以我上面**QQ音乐为例子**，其实在听歌的过程中，随着**OS的进程调度**，QQ音乐进程是**一直在运行态和就绪态**切换的。
### 3.1.4 阻塞态
&emsp;&emsp;**阻塞态**，就是进程在运行时，突然**缺失除了CPU以外的其他硬件资源**导致程序无法继续运行下去，**最常见的比如我们打印文件时，打印机处于脱机状态**，此时，打印对应的进程就会被阻塞，如下图所示，我的打印机处于脱机状态，也就是没有打印机硬件资源，我**点击打印**，出现的结果是，需要打印的文件一直处于**打印队列中**，不会打印下去，这就是**打印队列进程处于阻塞态**的一种表现，只有当**打印机硬件资源得到时**，**打印队列进程**才会被加入到就绪队列中，等待CPU的调度。
<center><img src="https://i-blog.csdnimg.cn/direct/2764b351c4d74ea1a6bff96e5a0854a0.png" width="85%"></center>
<center><img src="https://i-blog.csdnimg.cn/direct/f676f8140cde413f91cc451116e29d8c.png" width="85%"></center>

### 3.1.5 结束态
&emsp;&emsp;**结束态**，指的是进程**结束运行的状态**，还是以QQ音乐进程为例，当我不想听音乐了，我点击关闭按钮，此时，就会触发OS对QQ音乐进程的PCB进行**信息清除，并且释放PCB和所占用的硬件资源**，经历了**结束态**的进程，OS就**感知不到其对应程序的存在了**。
### 3.1.6 进程状态迁移图
&emsp;&emsp;介绍完进程的状态，我们可以通过**进程的状态迁移图**，对**进程五个状态的转换**有一个直观的理解。
<center><img src="https://i-blog.csdnimg.cn/direct/086c58d188c240dbb959ec0b2d4d7fd8.png" width="85%"></center>

## 3.2 进程调度
&emsp;&emsp;在进程状态转换中，我们谈到了**进程调度**这个概念，简单的理解就是**对运行态下的进程进行切换（注意：进程调度对应的状态转换只涉及到运行态和就绪态）**，让OS中**每一个进程**都有运行的机会（雨露均沾，不要让一些进程出现“饿死”），只有这样，多个系统进程和用户进程在**某一时间间隔内**都可以运行起来，我们的OS才能在**稳定的前提下**实现多样的功能。
&emsp;&emsp;知道了什么是进程调度，那么，OS是如何**通过进程调度实现运行态下进程的切换**呢？总不能对**运行态下的进程**想换就换吧。其实，OS系统有一系列的**进程调度算法**，根据进程调度算法来进行**运行态进程切换**，这样就根据综合因素，保证了对每一个进程都是公平的。常见的五种进程调度算法有：**先来先服务（First Come First Served，FCFS）调度算法，短进程优先（Shortest Job First，SJF）调度算法，时间片轮转（Round-Robin，RR）调度算法，优先级调度算法和多级反馈队列调度算法**。

### 3.2.1 FCFS调度算法
&emsp;&emsp;FCFS调度算法是**最简单的调度算法**，根据名字很好理解，就是**先到的进程先运行（这个先到怎么判断呢？可以根据创建进程的时间顺序来确定）**，该调度算法属于**非抢占式（就是一个进程占用了CPU，其他进程必须等它运行完毕才能抢占CPU）**。读者应该不难联想到，该算法直接**通过一个队列**即可实现（队列中存放PCB）。

 - 算法优点：实现简单，公平性高（制定了哪个进程先执行的规则）
 - 算法缺点：平均等待时间长（等待时间就是进程在整个运行期间，等待CPU的时间）
### 3.2.2 SJF调度算法
&emsp;&emsp;SJF调度算法是指**优先调度运行时间短的进程**，这个算法**通俗易懂**，读者应该很容易联想到求出每一个进程的运行时间，然后排序，得到进程的调度顺序。实际上，在进程创建之后，OS是**无法预知每一个进程的执行时间的**，试想一下，我们在编写程序的过程中，不同代码行对应的指令个数不一样，不同的指令所消耗的CPU时钟周期也不一样，而且程序中存在着大量的循环和调用，导致**判断同数量级循环的进程（程序）运行时间**几乎是不可能的。
 - 算法优点：平均等待时间短
 - 算法缺点：公平性不足，容易导致长运行时间进程出现饿死现象
### 3.2.3 RR调度算法
&emsp;&emsp;RR调度算法是一种**抢占式（进程没有执行完毕有时候也得让出CPU使用权）**调度算法。算法的基本执行流程是，按**就绪队列的顺序**为每一个进程分配时间片，当一个**正在执行的进程**时间片用完了，就将该进程**放到绪队列队尾**，然后从**就绪队列队头**调度另一个进程，为其分配时间片。
 - 优点：类似于FCFS调度算法，保证了公平性（以就绪队列的顺序来调度），此外，在一定的时间间隔内，保证了多个程序的并发性
 - 缺点：平均等待时间长
### 3.2.4 优先级调度算法
&emsp;&emsp;优先级调度算法，就是为每一个进程分配一个优先级（这个优先级可以分配到PCB中记录），OS按照进程的优先级进行调度，不难联想到，**SJF调度算法其实也有点类似于优先级调度算法**，只是SJF把最短时间作为了最高优先级，那么，对于优先级调度算法面临的缺点，可以**从SJF调度算法的角度来分析**。
 - 算法优点：可以自定义调度规则，保证了一定的公平性
 - 算法缺点：和SJF调度算法一样，优先级低的进程容易导致饿死现象，但是这个缺点可以通过**动态调整优先级**的方式来解决，对于等待时间长的进程，可以适当的提高其优先级

### 3.2.5 多级反馈队列调度算法
&emsp;&emsp;多级反馈队列调度算法，是在**多级队列调度算法**的基础上进行的改进。先简单说一下多级队列调度算法，它通过设置**多个队列**，每个队列都有**各自的调度算法（可以一样，也可以不一样）**，队列与队列之间设置优先级，**OS优先调用优先级高的队列**里面的进程，直到**优先级高的队列进程运行完毕**，才会调度**低优先级队列里面的进程**，不难想到，其实这也是存在一定问题的，那就是低优先级队列里面的进程也会发生**饿死现象**。所以就出现了**多级反馈队列调度算法**，它与多级队列调度算法的**唯一区别是允许低级队列的进程跃迁到高级队列中去**。

 - 算法优点：公平性高，可以自定义调度规则，可操作性强
 - 算法缺点：多级队列需要更多的存储空间
## 3.3 进程间通信
&emsp;&emsp;在**多进程并发执行**的OS中，进程间通信对于进程的管理也十分重要，试想一下这个常见的例子你的微信好朋友通过聊天，向你请教了一个技术性的问题，你想了很久，还是决定打开Chrome，将好朋友的问题**复制粘贴到了搜索引擎的框中**按下了搜索键，这种两个进程之间的消息传递，就是由OS的**进程间通信管理实现的**。那么，OS系统对于进程间的通信，又是通过哪些方法实现的呢？这里笔者介绍**管道、消息队列、共享内存和信号量机制**四种进程间通信方法。
<center><img src="https://i-blog.csdnimg.cn/direct/3d2f8a0aca224fe68cef26580c2e27f5.png" width="90%" ></center>

### 3.3.1 匿名管道
&emsp;&emsp;每一个程序被装载近内存之后，都会被存放到一个叫做**用户空间**的内存区，在这个内存区中，每一个进程都有自己独立的内存空间，**进程与进程之间的用户空间内存区是不可以相互访问的**，那么，用户空间**不可以实现**进程间传递数据，OS就考虑使用第三方媒介，如下图，**内核空间**来实现。**管道**就因此诞生了，所以，我们对**管道的概念**，就可以简单的理解为是**内核空间的一块内存区域**，进程间的通信都是**通过管道这个中转站**来传递数据的。那么，**匿名管道**又是什么呢？其实就是对**管道**的通信方式进行了一定的限制。这个限制可以总结为**三大块**：
- 限制亲子进程之间通信，**只允许父子和兄弟进程间使用匿名管道**
- 限制半双工通信，**只允许信息从一端流入，从另一端流出**，也可以理解为当父子进程使用**一个匿名管道**的时候，一个**只能从管道读信息**，另一个**只能从管道写信息**，要想实现双向通信，只能创建两个**匿名管道**
- 由于**匿名**，管道在内核空间没有标识符，所以就导致了**非亲子进程之间无法使用一个确定的标识符**去寻找同一个管道，这也是第一个限制的原因，那么读者就会问了，**为什么亲子进程之间可以找到同一个管道呢？** 这是因为子进程或者兄弟进程在创建的过程中，会继承**父进程的PCB块中的信息**，而PCB中存在管道的信息，所以子进程或者兄弟进程就可以通过相同的PCB信息来找到**匿名管道**。
<center><img src="https://i-blog.csdnimg.cn/direct/ac1ce2257d19407d883fcd17f3b22f27.png" width="75%" ></center>

### 3.3.2 有名管道
&emsp;&emsp;**有名管道**是对**匿名管道**的第一个和第三个限制做出的改进，但是和匿名管道一样，**只支持半双工通信**。具体的实现是，为管道绑定一个文件标识符，这个文件标识符是**OS中一个文件的路径**，这就不难想到，**有名管道**对于进程通信的数据存储，是基于磁盘的（和匿名管道比起来，笔者认为是一个缺点，**磁盘的读写速度慢于内存条**）。绑定文件标识符之后，由于标识符不属于进程的用户空间部分，支持不同进程间的相互访问，所以就解决了**匿名管道只支持父子和兄弟进程通信**的局限。
<center><img src="https://i-blog.csdnimg.cn/direct/c8d8d2e5f016477d8f5365ab7b3df48c.png" width="75%" ></center>

### 3.3.3 消息队列
&emsp;&emsp;介绍完**两个管道通信**之后，这里介绍一下**消息队列通信**，消息队列通信主要解决的是**有名管道通信**不能实现**异步通信**的问题。具体的，如下图，消息队列也是通过在内核空间创建一个**链式队列**，然后用一个**链表节点作为标识符**，供不同进程间通信。和**有名管道不同的是**，数据读取进程不受数据输入进程的影响，**只要消息队列中有数据，就能读取**，而数据输入进程也不受数据输出进程的影响，**只要消息队列中还存在空间，就能往消息队列里面写数据**，这就实现了**进程通信的异步性**。
<center><img src="https://i-blog.csdnimg.cn/direct/297178a95a8e4af2b05238834b46dfb1.png" width="75%" ></center>


### 3.3.4 信号量机制
&emsp;&emsp;**信号量机制**是进程间通信及其重要的部分，它是**进程同步与互斥**实现的基础。有关信号量机制的具体实现，笔者**强烈建议读者阅读相关的OS理论书籍（比如《现代操作系统 第三版》等）**，本文只针对入门对信号量机制进行简单介绍。
&emsp;&emsp;对于信号量，我们可以简单的理解为**其实就是一个整型变量**，它控制着进程对共享资源的**同步访问（同步访问可以简单的理解为多个进程对多个共享资源的非抢占式访问，比如，共享资源量为y，只有等y个进程中有进程对其访问完毕了，才允许其他进程对共享资源进行访问）**。这里，我们假设信号量初始值$sem = y$，表示共享资源量为$y$（信号量的初始值不可能大于共享资源的个数）。此时，$sem$的**取值有三种**情况，代表着**共享资源的三种状态**：

- $sem < 0$，表示此时$y$个**共享资源**都被$y$个进程占用着，而且有$|sem|$个进程因为需要访问该共享资源被阻塞
- $sem = 0$，表示此时$y$个**共享资源**刚刚好被$y$个进程占用着，而且没有进程需要访问该资源
- $sem > 0$，表示此时$y$个**共享资源**还剩下$sem$个，如果有不超过$sem$个进程访问该共享资源，不会发生阻塞

那么，**进程在对共享资源进行访问的过程中**，$sem$的值又是如何变化的呢，这里有**两种情况**：

- 进程需要**申请共享资源**，此时的资源数量$sem$应该**减1**
- 进程访问完共享资源之后，需要**释放共享资源**，此时的资源数量$sem$应该**加1**

至此，关于**信号量机制**的简单描述就完成了，理解了**上述两个规则**，其实就**理解了信号量机制**，它的**主要功能无非就是实现进程对共享资源的同步访问（这里顺便说一下进程互斥，互斥其实就是共享资源数量为1的情况，也叫临界资源，同一时间间隔内只能一个进程访问，是同步的一个特殊情况）**，实现原理不难，但是**有关信号量机制实现的一些进程同步算法**，值得读者继续深入研究，比如**银行家算法、读者写者算法和哲学家就餐问题等**。
### 3.3.5 共享内存
&emsp;&emsp;对比以上四种方法，共享内存是**最快的进程间通信（Inter-Process Communication，IPC）** 方式，在多个进程交换数据时，**共享内存的方式使OS**在内核空间中创建一块内存区域，并且**让需要访问该内存区域的进程**将这块内存区域映射到**自己的进程地址空间**，那么，这个映射是怎么**提高进程间的通信效率**呢？如下图所示，共享内存的方式**不需要进程拷贝数据到自己的进程地址空间中**，而是直接通过地址映射表，拿到内核空间的地址，然后直接访问共享内存（内核空间）中的数据。上述三个方法的进程通信方式为，**从内核空间或者磁盘中拷贝数据**到自己的进程地址空间中，拷贝过程中，不仅浪费了进程的地址空间，还多出了时间开销。
<center><img src="https://i-blog.csdnimg.cn/direct/44a49529c7b64b2eabb3501447655a46.png" width="75%" ></center>

---
# 🎉总结
&emsp;&emsp;至此，操作系统科普与入门之进程篇就结束了，该部分用通俗的语言描述了从什么是OS，OS各个管理模块对应着哪些硬件资源（理解了操作系统，对于以后自己组装电脑，就知道为什么要买那些硬件了）。最后，文章主体的第三部分介绍了OS的进程管理部分，这部分笔者仅仅只是用简单的语言进行了描述，不管是进程的状态转换，进程调度，还是进程间的通信，都非常的重要，仅仅阅读本篇文章，**只是对进程管理有了一个宏观上的把握**，更多细节的东西，需要读者自行阅读相关的OS资料。